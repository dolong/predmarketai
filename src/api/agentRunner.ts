import { Agent, ProposedQuestion } from '../lib/types';
import { questionsApi } from '../lib/supabase';

/**
 * Agent Runner Service
 *
 * This service handles executing AI agents to generate questions.
 * It can be used by:
 * - Frontend UI (Run Now button)
 * - Backend cron jobs
 * - Scheduled agent execution
 */

interface AgentRunResponse {
  question: string;
  description?: string;
  liveDate?: string | Date;
  answerEndAt?: string | Date;
  settlementAt?: string | Date;
  resolutionCriteria?: string;
  aiScore?: number;
  type?: 'binary' | 'multi-option';
  categories?: string[];
  riskFlags?: string[];
}

interface AgentRunResult {
  success: boolean;
  question?: ProposedQuestion;
  error?: string;
}

export class AgentRunner {
  /**
   * Execute an agent to generate a new question
   * @param agent The agent to run
   * @returns Result of the agent execution
   */
  static async runAgent(agent: Agent): Promise<AgentRunResult> {
    try {
      // Validate agent has an API source
      const apiSource = agent.sources.find(source => source.type === 'api');

      if (!apiSource?.config?.apiEndpoint) {
        return {
          success: false,
          error: 'No API endpoint configured for this agent'
        };
      }

      const apiEndpoint = apiSource.config.apiEndpoint;

      // Prepare request body
      const requestBody = {
        Question: agent.questionPrompt,
        AgentId: agent.id,
        AgentName: agent.name
      };

      console.log(`[AgentRunner] Running agent "${agent.name}" (${agent.id})`);
      console.log(`[AgentRunner] API Endpoint: ${apiEndpoint}`);

      // Call the API
      const response = await fetch(apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        return {
          success: false,
          error: `API request failed with status ${response.status}: ${response.statusText}`
        };
      }

      const responseText = await response.text();

      if (!responseText || responseText.length === 0) {
        return {
          success: false,
          error: 'API returned empty response'
        };
      }

      // Parse API response
      let data: AgentRunResponse;
      try {
        data = JSON.parse(responseText);
      } catch (jsonError) {
        return {
          success: false,
          error: `API returned invalid JSON: ${responseText.substring(0, 100)}...`
        };
      }

      // Validate required fields
      if (!data.question) {
        return {
          success: false,
          error: 'API response missing required "question" field'
        };
      }

      console.log(`[AgentRunner] Successfully received question: "${data.question.substring(0, 50)}..."`);

      // Parse dates from API response or use defaults
      const now = new Date();
      const liveDate = data.liveDate
        ? new Date(data.liveDate)
        : new Date(now.getTime() + 60 * 60 * 1000); // 1 hour from now

      const answerEndAt = data.answerEndAt
        ? new Date(data.answerEndAt)
        : new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours from now

      const settlementAt = data.settlementAt
        ? new Date(data.settlementAt)
        : new Date(answerEndAt.getTime() + 60 * 60 * 1000); // 1 hour after answer end

      // Build the proposed question
      const proposedQuestion: ProposedQuestion = {
        id: `gq${Date.now()}`,
        title: data.question,
        description: data.description || `Generated by ${agent.name}`,
        liveDate: liveDate,
        answerEndAt: answerEndAt,
        settlementAt: settlementAt,
        resolutionCriteria: data.resolutionCriteria || agent.resolutionPrompt,
        agentId: agent.id,
        aiScore: data.aiScore !== undefined ? data.aiScore : 1.0,
        riskFlags: data.riskFlags || [],
        createdAt: now,
        state: 'pending',
        // Use categories from API response, or fall back to agent category
        categories: data.categories || (agent.category ? [agent.category] : []),
        type: data.type || 'binary',
      };

      console.log(`[AgentRunner] Saving question to database...`);

      // Save question to database
      const savedQuestion = await questionsApi.createQuestion(proposedQuestion);

      if (!savedQuestion) {
        return {
          success: false,
          error: 'Failed to save question to database'
        };
      }

      console.log(`[AgentRunner] Successfully saved question with ID: ${savedQuestion.id}`);

      return {
        success: true,
        question: savedQuestion
      };

    } catch (error) {
      console.error(`[AgentRunner] Error running agent "${agent.name}":`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    }
  }

  /**
   * Run multiple agents in sequence
   * Useful for cron jobs that need to execute all active agents
   * @param agents Array of agents to run
   * @returns Results for each agent execution
   */
  static async runAgents(agents: Agent[]): Promise<AgentRunResult[]> {
    const results: AgentRunResult[] = [];

    for (const agent of agents) {
      // Only run active agents
      if (agent.status === 'active') {
        console.log(`[AgentRunner] Running agent: ${agent.name}`);
        const result = await this.runAgent(agent);
        results.push(result);

        // Add a small delay between agents to avoid overwhelming APIs
        await new Promise(resolve => setTimeout(resolve, 1000));
      } else {
        console.log(`[AgentRunner] Skipping inactive agent: ${agent.name} (status: ${agent.status})`);
      }
    }

    return results;
  }

  /**
   * Run agents that match a specific frequency
   * Useful for cron jobs scheduled at different intervals
   * @param agents Array of agents to filter and run
   * @param frequency The frequency to match (daily, weekly, on_update)
   * @returns Results for each agent execution
   */
  static async runAgentsByFrequency(
    agents: Agent[],
    frequency: 'daily' | 'weekly' | 'on_update'
  ): Promise<AgentRunResult[]> {
    const filteredAgents = agents.filter(
      agent => agent.frequency === frequency && agent.status === 'active'
    );

    console.log(`[AgentRunner] Found ${filteredAgents.length} agents with frequency "${frequency}"`);

    return this.runAgents(filteredAgents);
  }
}

// Export a default instance for convenience
export const agentRunner = AgentRunner;
